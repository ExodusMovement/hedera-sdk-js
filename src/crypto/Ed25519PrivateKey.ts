import * as nacl from "tweetnacl";
import { Ed25519PublicKey } from "./Ed25519PublicKey";
import {
    arraysEqual,
    deriveChildKey,
    deriveChildKey2,
    ed25519PrivKeyPrefix
} from "./util";
import { RawKeyPair } from "./RawKeyPair";
import { BadKeyError } from "../errors/BadKeyError";
import { BadPemFileError } from "../errors/BadPemFileError";
import { decodeDer } from "./der";
import * as base64 from "../encoding/base64";
import * as hex from "@stablelib/hex";
import { Hmac, HashAlgorithm } from "./Hmac";
import { Pbkdf2 } from "./Pbkdf2";

const beginPrivateKey = "-----BEGIN PRIVATE KEY-----\n";
const endPrivateKey = "-----END PRIVATE KEY-----\n";

const beginEncryptedPkey = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n";
const endEncryptedPkey = "-----END ENCRYPTED PRIVATE KEY-----\n";

const derPrefix = hex.decode("302e020100300506032b657004220420");

function _bytesLengthCases(bytes: Uint8Array): nacl.SignKeyPair {
    // this check is necessary because Jest breaks the prototype chain of Uint8Array
    // noinspection SuspiciousTypeOfGuard
    const bytesArray = bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes);

    switch (bytes.length) {
        case 48:
            // key with prefix
            if (arraysEqual(bytesArray.subarray(0, 16), derPrefix)) {
                return nacl.sign.keyPair.fromSeed(bytesArray.subarray(16));
            }
            break;
        case 32:
            // fromSeed takes the private key bytes and calculates the public key
            return nacl.sign.keyPair.fromSeed(bytesArray);
        case 64:
            // priv + pub key pair
            return nacl.sign.keyPair.fromSecretKey(bytesArray);
        default:
    }
    throw new BadKeyError();
}

export class Ed25519PrivateKey {
    public readonly publicKey: Ed25519PublicKey;

    // NOT A STABLE API
    public readonly _keyData: Uint8Array;
    private _asStringRaw?: string;
    private _chainCode?: Uint8Array;

    private constructor({ privateKey, publicKey }: RawKeyPair) {
        if (privateKey.length !== nacl.sign.secretKeyLength) {
            throw new BadKeyError();
        }

        this._keyData = privateKey;
        this.publicKey = Ed25519PublicKey.fromBytes(publicKey);
    }

    /**
     * Recover a private key from its raw bytes form.
     *
     * This key will _not_ support child key derivation.
     */
    public static fromBytes(bytes: Uint8Array): Ed25519PrivateKey {
        const keypair = _bytesLengthCases(bytes);

        const { secretKey: privateKey, publicKey } = keypair;

        return new Ed25519PrivateKey({ privateKey, publicKey });
    }

    /**
     * Recover a key from a hex-encoded string.
     *
     * This key will _not_ support child key derivation.
     */
    public static fromString(keyStr: string): Ed25519PrivateKey {
        switch (keyStr.length) {
            case 64: // lone private key
            case 128: { // private key + public key
                const newKey = Ed25519PrivateKey.fromBytes(hex.decode(keyStr));
                newKey._asStringRaw = keyStr;
                return newKey;
            }
            case 96:
                if (keyStr.startsWith(ed25519PrivKeyPrefix)) {
                    const rawStr = keyStr.slice(32);
                    const newKey = Ed25519PrivateKey.fromBytes(hex.decode(rawStr));
                    newKey._asStringRaw = rawStr;
                    return newKey;
                }
                break;
            default:
        }
        throw new BadKeyError();
    }

    /**
     * Recover a key from a 24 or 22-word mnemonic.
     *
     * There is no corresponding `toMnemonic()` as the mnemonic cannot be recovered from the key.
     *
     * Instead, you must generate a mnemonic and a corresponding key in that order with
     * `generateMnemonic()`.
     *
     * This accepts mnemonics generated by the Android and iOS mobile wallets.
     *
     * This key *will* support deriving child keys with `.derive()`.
     *
     * If the mnemonic has 22 words, the resulting key will not support deriving child keys.
     *
     * @param mnemonic the mnemonic, either as a string separated by spaces or as a 24-element array
     * @param passphrase the passphrase to protect the private key with
     *
     * @link generateMnemonic
     */
    public static async fromMnemonic(
        mnemonic: any, // accept strings
        passphrase: string
    ): Promise<Ed25519PrivateKey> {
        if (mnemonic._isLegacy) {
            return mnemonic._legacyToPrivateKey();
        }

        const input = mnemonic.toString();
        const salt = `mnemonic${passphrase}`;
        const seed = await Pbkdf2.deriveKey(HashAlgorithm.Sha512, input, salt, 2048, 64);

        const digest = await Hmac.hash(HashAlgorithm.Sha512, "ed25519 seed", seed);

        let keyBytes: Uint8Array = digest.subarray(0, 32);
        let chainCode: Uint8Array = digest.subarray(32);

        for (const index of [ 44, 3030, 0, 0 ]) {
            ({ keyBytes, chainCode } = deriveChildKey(keyBytes, chainCode, index));
        }

        const key = Ed25519PrivateKey.fromBytes(keyBytes);
        key._chainCode = chainCode;
        return key;
    }

    /**
     * Generate a new, cryptographically random private key.
     *
     * This key will _not_ support child key derivation.
     */
    // eslint-disable-next-line require-await
    public static async generate(): Promise<Ed25519PrivateKey> {
        return this.fromBytes(nacl.randomBytes(32));
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation`
     *
     * @deprecated `Ed25519PrivateKey.derive()` is deprecated and will eventually be replaced with the async variant `Ed25519PrivateKey.derive2()`
     */
    public derive(index: number): Ed25519PrivateKey {
        console.warn("`Ed25519PrivateKey.derive()` is deprecated and will eventually be replaced with the async variant `Ed25519PrivateKey.derive2()`");
        if (this._chainCode == null) {
            throw new Error("this Ed25519 private key does not support key derivation");
        }

        const {
            keyBytes,
            chainCode
        } = deriveChildKey(this._keyData.subarray(0, 32), this._chainCode, index);

        const key = Ed25519PrivateKey.fromBytes(keyBytes);
        key._chainCode = chainCode;

        return key;
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation`
     *
     * Will eventually replace `Ed25519PrivateKey.derive()`
     */
    public async derive2(index: number): Promise<Ed25519PrivateKey> {
        if (this._chainCode == null) {
            throw new Error("this Ed25519 private key does not support key derivation");
        }

        const {
            keyBytes,
            chainCode
        } = await deriveChildKey2(this._keyData.subarray(0, 32), this._chainCode, index);

        const key = Ed25519PrivateKey.fromBytes(keyBytes);
        key._chainCode = chainCode;

        return key;
    }

    /** Check if this private key supports deriving child keys */
    public get supportsDerivation(): boolean {
        return this._chainCode != null;
    }

    public toBytes(): Uint8Array {
        // copy the bytes so they can't be modified accidentally
        // only copy the private key portion since that's what we're expecting on the other end
        return this._keyData.slice(0, 32);
    }

    public toString(raw = false): string {
        if (this._asStringRaw == null) {
            // only encode the private portion of the private key
            this._asStringRaw = hex.encode(this._keyData.subarray(0, 32), true);
        }

        return (raw ? "" : ed25519PrivKeyPrefix) + this._asStringRaw;
    }
}
